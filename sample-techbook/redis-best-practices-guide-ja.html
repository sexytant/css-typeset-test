<link href="layout.css" rel="stylesheet" /><h1>Redis Best Practices Guide (日本語版)</h1>
<h1>イントロダクション</h1>
<p>Redisは数え切れないほどの使い方ができますが，よくある問題を解決するために採用されるパターンがいくつもあります．そこで，これらの問題を解決するためのベストプラクティスと思われる一般的なパターンを集めてみました．このコレクションは網羅的なものではありませんし，Redisの唯一の使い方を示すものでもありませんが，Redisで解決すべき問題に取り組む際の最初の一歩になればと思います．
このベストプラクティス・ガイドは，必要に応じて複数のセクションとサブセクションに分かれています．</p>
<h2>インデックス・パターン</h2>
<p>RedisでKey-Valueアクセスを超える方法について説明します．これは，特定のキースペース・パターンとRedisのさまざまな構造の両方を賢く使って，データベース内のデータを見つけるのを助けるだけでなく，アクセスの複雑さを軽減する方法を含みます．</p>
<h2>コミュニケーション・パターン</h2>
<p>システム内でデータを移動させるRedisパターンに焦点を当てます．この状況では，Redisはストレージエンジンとしてではなく，データの経路として動作しています．</p>
<h2>データストレージ・パターン</h2>
<p>より複雑なデータをRedisに保存するための方法を説明します．単純にも複雑にも一般化できる複雑なドキュメントのシナリオを評価しています．</p>
<h2>時系列パターン</h2>
<p>時系列データに関するパターンを取り扱います．</p>
<h2>レートリミット・パターンの基礎</h2>
<p>レートリミットはRedisの一般的な使用方法です．この利用方法の基礎を解説しています．</p>
<h2>プルームフィルター・パターン</h2>
<p>以前からRedisと関連しており，確率的データ構造の用途と非確率的データ構造との違いについて説明します．</p>
<h2>カウント</h2>
<p>このセクションでは，空間的かつ計算効率の良い方法で，アクティビティとユニークなアイテムをカウントする方法を探ります．意外と奥が深いテーマです．</p>
<h2>LuaHelpers</h2>
<p>最後に，Redisがより少ないコストでより多くの処理を行うために，Luaを活用する方法について説明します．</p>
<hr />
<p>このガイドは直線的なものではありませんので，もっと知りたいという方はどこからでも始められます．そうでなければ，ナビゲーションツリーを使って，自分に最も関係のあるトピックを見つけることができます．</p>
<p>:::message
<strong>ソースコードがないことについての注意</strong></p>
<p>可能な限り，これらのコレクションは，ロジック/フローの説明のみを含む簡単なコマンドで表示されます．言語固有の実装の詳細は意図的に排除しています．これは，Redisユーザーの多様性を反映し，シンタックスや言語構造に関する不要な説明を避けるためです．
:::</p>
<h1>インデックスパターン</h1>
<p>概念的にはRedisは，Key-Valueデータベースのパラダイムをベースにしています．すべてのデータは，直接的または間接的にキーに関連付けられています．もし，キー以外のものに基づいてデータを取得したい場合は，Redisで利用可能な多くのデータ型のうちの一つを活用したインデックスを実装する必要があります．</p>
<p>Redisにおけるインデックスは他のデータベースとは大きく異なり，特定の用途やデータによって最適なインデックス作成戦略が決定されます．このセクションでは，単純なKey-Value検索を越えてデータを見つけるための，より一般的な戦略をいくつか紹介します．</p>
<h2>インデックスとしてのソート済みセット</h2>
<p>ソート済みセット（ZSET）は，ユニークなメンバー（同一のメンバーは保存できません）の集合と考えることができ，各メンバーは自然な順序として数値（スコア）が添えられています．メンバーは繰り返すことができませんが，任意の数のメンバーが同じスコアを持つことができます．(順位またはスコアによる)範囲の追加，削除，取得にかかる時間が比較的短いため，インデックスとして使用するのに適しています．例として，世界の国々を人口順に並べたとしましょう．</p>
<p>```</p>
<blockquote>
<p>ZADD countries-by-pop china 1409517397
… every country population … 
ZADD countries-by-pop vatican-city 792
<code>上位5カ国を取得するには，単に次のようにします</code>
ZRANGE countries-by-pop 0 4
<code>人口が1,000,000から100,000の範囲にある国々を取得するには</code>
ZRANGEBYSCORE countries-by-pop 100000 1000000
```
複数のインデックスを作成することで，データのさまざまな並べ替え方法を表現することができます．この例では，同じメンバーを使用しますが，人口の代わりに，人口密度，地理的な大きさ，インターネットユーザー数などを使用することができます．こうすることで，データの複数の側面に対して高性能なインデックスを作成することができます．さらに，メンバー名をRedis自身（Hashなど）や他のデータストアに保存されている詳細項目と共有することで，セカンダリプロセスは必要に応じて各項目に関する追加情報を取得することができます．</p>
</blockquote>
<h2>字句エンコーディング</h2>
<p>ソート済みセット(ZSET)は，スコアによるランキングの他に，アルファベットのソート機構を作るために利用できるという興味深い性質を持っています．それは，同じスコア毎に境界付きで，メンバーを辞書順に返すことができる，というものです．次のようなデータを取り上げてみましょう．
```</p>
<blockquote>
<p>ZADD animal-list 0 bison 0 boa 0 dog 0 emu 0 falcon 0 alligator 0 chipmunk
<code>上のコマンドは，キーとなる動物リストにいくつかの動物を追加するものです．どのメンバーも全て同じスコア(0)です．ZRANGEコマンドを引数0（最初の項目を表す）と-1（スコアで「最後の」メンバーを表す）で実行すると，不思議な順序になることがわかります．</code>
ZRANGE animal-list 0 -1
1) "alligator"
2) "bison"
3) "boa"
4) "chipmunk"
5) "dog"
6) "emu"
7) "falcon"
<code>アルファベット順でない項目が入力されているにもかかわらず，アルファベット順に正しくソートされて返されます．このソート順は，実際にはバイナリセーフでバイト単位で文字列比較が行われた結果です．つまり，ASCII文字は英語のアルファベット順に正しくソートされて返されることになります．これにはいくつかの意味があります．
 - 小文字と大文字が同じ文字として認識されません
 - マルチバイト文字は期待通りの方法でソートされません
また，Redisは字句検索をさらに絞り込むための高度な機能を提供しています．例として，'b'で始まり'e'で終わる動物を返したい場合を考えてみましょう．</code>
ZRANGEBYLEX animal-list [b (f
1) "bison"
2) "boa"
3) "chipmunk"
4) "dog"
5) "emu"
<code>引数の (f は少し意外かもしれませんね．これは重要なポイントです．Redisはアルファベットを理解するという概念がないため，eで始まるものはその後の文字に関係なく，常にfで始まるものの前にソートされると考えなければならないことを意味します．その他の注意点としては，角括弧 **[** は包含検索を，括弧 **(** は排他検索を表しています．この場合，bはリストに含まれるが，fはリストに含まれないということです．もし，ある時点より過去のすべての項目を取得したい場合は，最後の文字の16進エンコーディング(255または0xFF)を使用します．</code>
ZRANGEBYLEX animal-list [c "[xff"
1) "chipmunk"
2) "dog"
3) "emu"
4) "falcon"
<code>この同じコマンドを制限して，ページング効果を与えることもできます．たとえば，次のようなコマンドです．</code>
ZRANGEBYLEX animal-list [b (f LIMIT 0 2
1) "bison"
2) "boa"
ZRANGEBYLEX animal-list [b (f LIMIT 2 2
1) "chipmunk"
2) "dog"
```
唯一の注意点は，オフセット（LIMITの後の最初の引数）に基づいて，時間の複雑さが増し続けることです．つまり，例えば100万個のメンバーがいて，最後の2個を取得しようとすると，100万個のアイテムすべてを走査する必要があります．</p>
</blockquote>
<h2>地理的データ</h2>
<p>Redisには地理空間インデックスに関連するいくつかのコマンド（GEOコマンド）がありますが，他のコマンドと異なり，これらのコマンドには独自のデータ型がありません．これらのコマンドは実際にはソートされたセットのデータ型におんぶに抱っこです．これは，geohash アルゴリズムを使用して，緯度と経度をソートされたセットのスコアにエンコードすることで実現されています．
地理空間インデックスに項目を追加するのは簡単です．例として，道路を走行する車のグループを追跡しているとします．この車の集合を単に "cars" と呼ぶことにします．あなたの特定の車は，メンバー "my-car" として識別できるとします（ジオインデックスは集合の一形態に過ぎないので，メンバーという用語を使用します）．この集合に車を追加するには，次のコマンドを実行します．
```</p>
<blockquote>
<p>GEOADD cars -115.17087 36.12306 my-car 
<code>第一引数は追加するセット，第二引数は経度，第三引数は緯度，第四引数はメンバー名です．
車の位置を更新するには，新しい座標でコマンドを再度実行するだけです．これは，ジオインデックスが単なるセットであり，繰り返しのアイテムは許可されていないためです．</code>
GEOADD cars -115.17172 36.12196 my-car
<code>2台目の車を "cars" セットに追加してみましょう．今度はロビンが運転します．</code>
GEOADD cars -115.171971 36.120609 robins-car
<code>座標を見ると，この2台はかなり近いことがわかりますが，どのくらい近いのでしょうか？GEODISTコマンドを実行することによって，それを知ることができます．</code>
GEODIST cars my-car robins-car
"90.7082"
<code>これは，2台の車が約90メートル離れていることを意味します．また，他の単位を指定することもできます．</code>
GEODIST cars my-car robins-car ft
"297.5990"
```
これによって，同じ距離をフィートで取得したことになります．マイル(mi)やキロメートル(km)を使うこともできます．</p>
</blockquote>
<p>では，ある地点から半径の範囲にどんなものがあるか見てみましょう．
```</p>
<blockquote>
<p>GEORADIUS cars -115.17258 36.11996 100 m
1) "my-car"
2) "robins-car"
<code>これは，指定された地点から100メートル以内にいるすべてのメンバーを返します．また，セット内の別のメンバーの半径内のメンバーを返すこともできます．</code>
GEORADIUSBYMEMBER cars robins-car 100 m
1) "robins-car"
2) "my-car"
<code>また，オプションの引数WITHDISTを追加することで，距離を含めることもできます．これはGEORADIUSやGEORADIUSBYMEMBERに対して機能します．</code>
GEORADIUSBYMEMBER cars robins-car 100 m WITHDIST
1) 1) "robins-car"
   2) "0.0000"
2) 1) "my-car"
   2) "90.7082"
<code>GEORADIUS と GEORADIUSBYMEMBER のもう一つのオプションの引数は WITHCOORD で，これは各メンバーの座標を返します．WITHDISTとWITHCOORDは一緒に使うことも，別々に使うこともできます．</code>
GEORADIUSBYMEMBER cars robins-car 100 m WITHDIST WITHCOORD
1) 1) "robins-car"
   2) "0.0000"
   3) 1) "-115.17197102308273315"
      2) "36.12060917648089031"
2) 1) "my-car"
   2) "90.7082"
   3) 1) "-115.17258256673812866"
      2) "36.11996028786411017"
<code>地理空間インデックスはソート済みセットの操作の代替手段に過ぎないので，ソート済みセットのコマンドを使うだけで実現できる操作もあります．"cars" セットから "my-car" を削除するには，ソート済みセットのコマンドである ZREM を使用する必要があります．</code>
ZREM cars my-car
```
Redisは豊富な地理空間操作ツールを提供していますが，このパターンではその基本的な部分のみを取り上げました．コマンドの完全なセットについては，<a href="redis.io">redis.io</a>で読むことができます．</p>
</blockquote>
<h2>IP範囲のインデックス</h2>
<p>接続されたサービスの実際の位置を知ることは，非常に便利なことです．IPロケーションテーブルはかなり大きくなりがちで，効率的に管理することは難しいです．そこで，ソート済みセットのデータ型を使って，迅速かつ効率的なIP位置情報サービスを実装することができます．</p>
<p>IPv4アドレスは，ランダムな例として74.125.43.99のようなドット10進数表記で，人類からは最もよく利用されます．しかし，ネットワークサービスでは，この同じアドレスを32ビットの数値として捉え，各バイトがドット10進数表記の4つの数値のうちの1つを表します．上記の例では，16進数で0x4A7D2B63，10進数で1249717091となります．</p>
<p>IPアドレスから位置情報へのデータセットは広く利用されており，通常，3つの列 開始，終了，位置 を持つ単純な表の形式をとっています．開始と終了は，IPv4アドレスの10進数表現で表されます．Redisでは，IP範囲に「穴」がないため，あるアドレス範囲の「終わり」が別のアドレス範囲の「始まり」であると（安全に）仮定できるため，ソート済みセットをこの形式に適合させることができます．</p>
<p>この単純化された例では，いくつかの範囲をソートされたセットに追加してみましょう．
```</p>
<blockquote>
<p>ZADD ip-loc 1249716479 us:1
ZADD ip-loc 1249716735 taiwan:1
ZADD ip-loc 1249717759 us:2
ZADD ip-loc 1249718015 finland:1
```
最初の引数はソート済みセットのキー，2番目の引数はIPアドレス範囲の末尾の10進数表現，最後の引数はメンバーです．ソート済みセットのメンバーには，最後のコロンの後に数字が連結されていることに注意してください．これは，この例を単純化するためだけです．実際のIPロケーションテーブルでは，各範囲に一意な識別子を持つことになります(国以外の情報もあります)．</p>
</blockquote>
<p>与えられたIPアドレスに対してテーブルを照会するには，RedisのコマンドであるZRANGEBYSCOREにいくつかの引数を追加して使用することができます．しかし，最初に人間が読めるIPアドレスを受け取り，それを10進数に変換します．これは好きな言語で行うことができます．まず最初に，最初の例のアドレス74.125.43.99または10進数で1249717091を使用します．この数字を最小値とし，最大値を持たず，最初のエントリだけに結果を限定すると，その場所がわかります．
```</p>
<blockquote>
<p>ZRANGEBYSCORE ip-loc 1249717091 +inf LIMIT 0 1
1) "us:2"
```
最初の引数はソート済みセットのキーで，2番目はIPアドレスを10進数で表したものです．3番目（+inf）はredisに範囲の上限を設定しないように指示し，最後の3つの引数はオフセット0で1つの結果しか返さないことを示します．</p>
</blockquote>
<h2>全文検索</h2>
<p>モジュールが登場する以前は，全文検索はRedisネイティブコマンドで実装されていました．RediSearchモジュールは，このパターンに比べてはるかに高いパフォーマンスを提供します．ただし，環境によってはRediSearchを利用できないこともあります．さらに，このパターンは非常に興味深いもので，RediSearchが理想的でないような他のワークロードに一般化することができます．</p>
<p>例えば，多数のテキスト文書を検索したいとします．これは，テーブルではなくキーでアクセスするため，Redisにとっては苦手なユースケースだと思うかも知れませんが，苦手どころか，Redisは非常に斬新な全文検索エンジンを支えるために使うことができるのです．</p>
<p>まず，いくつかの例を挙げてみましょう
“Redis is very fast”
“Cheetahs are fast”
“Cheetahs have spots”
簡単のために，これらの項目をスペースで区切っただけの単語の集合に分解してみましょう．
```</p>
<blockquote>
<p>SADD ex1 redis is very fast
SADD ex2 cheetahs are very fast
SADD ex3 cheetahs have spots
```
各行に独自のセット（ex1...）を与え，各単語に基づいてそのセットに複数のメンバーを追加していることに注意してください（行全体を追加しているように見えても，SADDは可変長なので複数のメンバーを受け入れることができます）．また，すべての単語を小文字にしました．</p>
</blockquote>
<p>次に，このインデックスを反転させて，どの単語がどの文書にあるかを表示する必要があります．そのために，単語ごとにセットを作って，ドキュメントセット名をメンバにします．
```</p>
<blockquote>
<p>SADD redis ex1
SADD is ex1
SADD very ex1 ex2
SADD fast ex1 ex2
SADD cheetahs ex2 ex3
SADD have ex3
SADD spots ex3
```
わかりやすくするために，個々のコマンドに分割していますが，通常はすべてのコマンドをMULTI/EXECブロックでアトミックに実行します．</p>
</blockquote>
<p>この小さな全文検索インデックスに問い合わせるために，SINTERコマンド（set intersect）を使用することにします． "very"と "fast"を持つ文書を検索するには
```</p>
<blockquote>
<p>SINTER very fast
1) "ex2"
2) "ex1"
<code>クエリにマッチする文書がない状況では，空の結果を得ることになります．</code>
SINTER cheetahs redis
(empty list or set)
<code>論理的な検索を行いたい場合は，SINTERの代わりにSUNION（集合の和集合）を使用することができます．</code>
SUNION cheetahs redis
1) "ex2"
2) "ex3"
3) "ex1" 
<code>インデックスから項目を削除するのは，もう少し複雑です．まず，文書集合（SMEMBERS）から文書インデックスのメンバを取得し，次に単語インデックスから文書IDを削除します．</code>
SMEMBERS ex3
1) "have"
2) "cheetahs"
3) "spots"
SREM have ex3
SREM cheetahs ex3
SREM spots ex3
```
これはRedisでは1回の操作では完了しないので，SMEMBERSで結果を取得した後にSREMコマンドを発行する必要があります．</p>
</blockquote>
<p>もちろん，これはごく単純な全文検索です．Setコマンドの代わりにSorted Setコマンドを使うことで，より反射的なインデックスを作成することができます．こうすることで，例えば，ある文書にある単語が複数回含まれている場合，1回しか含まれていない文書よりも「上位」に表示させることができます．上記のパターンは，Sorted Setコマンドを使用する以外は，ほぼ同じです．</p>
<h2>部分インデックス</h2>
<p>Redisのシングルインスタンス（またはシャード）は非常に高性能ですが，インデックスを複数のインスタンスにまたがるようにしたい状況もあります．例えば，並列化によるスループットの向上や，インスタンスのサイズを超えるインデックスを作成する場合などです．いくつかのキーに対して操作を行いたいとしましょう．キーを分割する効果的な方法は，キーの一様な分散スライスを各パーティションに提供し，各パーティションで必要な操作を並行して行い，最後にその結果をマージすることです．</p>
<p>理想的な方法で鍵の一様な分散を実現するために，非暗号化ハッシュアルゴリズムを採用することにしましょう．高速なハッシュ関数であれば何でも良いのですが，この例ではおなじみの<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC-32</a>を使用することにします．ほとんどの場合，人間はハッシュアルゴリズムの出力を16進数で見ることになります（例として，"my-cool-document "はCRC-32の出力をF9FDB2C9と表示します）．16進数表現は人間にとって簡単なだけで，10進数の整数値の代替表現に過ぎず，この値で計算ができることを意味します．</p>
<p>次に，パーティションの数を決定する必要があります．これは，少なくともインスタンスの数の2倍であるべきです．インスタンスを追加する必要がある場合，パーティションを別のインスタンスに移動させることができます．例えば，3つのインスタンスと6つのパーティションがあるとします．</p>
<p>ある文書が置かれるパーティションを計算するために，次のような操作を行います．</p>
<p>HashFunction(document_id) mod 分割の数</p>
<p>もし，"my-cool-document "が6つのパーティションで構成されているとしたら，次のように動作します．</p>
<p>CRC32("my-cool-document") = F9FDB2C9 (16進数) または 4194153161 (10進数)</p>
<p>$$
4194153161 = 5 ({\rm mod} 6)
$$</p>
<p>Redis Enterpriseでは，あらかじめ定義された正規表現を使用するか，キーの一部を中括弧で囲むことによって，キーがどのシャードに送られるかを制御することができます．つまり，この例では，このドキュメントのキーを次のように設定できます．</p>
<p>idx:my-cool-document{5}</p>
<p>次に「my-other-document」という別の文書があり，その文書のパーティション番号は3なので，キーは次のようになります．</p>
<p>idx:my-other-document{3}</p>
<p>この文書に関連する補助的な鍵がある場合，それらを同じシャード上に置いて，クロスロットエラーを起こさずに両方の鍵に対して同時に操作を行えるようにします．このためには，実際のドキュメントと同じパーティション番号をキーに追加する必要があります．</p>
<p>データを拡大して確認すると，インデックスがパーティション間でかなり均等に分割されていることがわかります．各パーティションで達成すべき作業を並列化することができます．インデックス全体に対して行うべき作業がある場合，クライアントは各パーティションに対して同じロジックを実行し，結果を取得し，クライアントで必要なマージを行う必要があります．</p>
<h1>コミュニケーション・パターン</h1>
<p>Redisは従来のデータベースとして機能するだけでなく，その構造やコマンドをマイクロサービスやプロセス間の通信媒体として利用することができます．Redisクライアントのユビキタス性，サーバーとプロトコルの両方の速度と効率性，そしてビルトインの古典的な構造により，カスタムのワークフローやイベント機構を構成することができます．このセクションでは，以下を検証します．</p>
<h2>イベントキュー</h2>
<p>Redisの Lists は文字列の順序付きリストで，皆さんがよくご存知のリンクリストと非常によく似ています．プッシュ（リストに値を追加すること），ポップ（リストから値を削除すること）は非常に軽い操作です（左/先頭/始点または右/末尾/終点のどちらかから）．ご想像の通り，これはキューを管理するのに非常に適した構造です．先入れ先出し（FIFO）キューでは，リストへのアイテムを先頭に追加し，末尾からアイテムを読み出すようにします．</p>
<p>Redisはこの種のパターンをより効率的で信頼性が高く，使いやすくするための追加機能も提供しています．リストコマンドの中には，"ブロッキング"動作を可能にするサブセットがあります．ブロッキング"という用語は，接続されているクライアントが1つの場合にのみ適用されます．事実上，これらのコマンドは，リストに値が入るまで（あるいはタイムアウトが経過するまで）クライアントの操作を停止させます．これにより，Redisをポーリングして結果を得る必要がなくなります．値を待っている間，クライアントは何もできないので，これを説明するために，2つのオープンなクライアントが必要です．</p>
<table>
<thead>
<tr>
<th style="text-align: left;">R</th>
<th style="text-align: left;">Sending Client</th>
<th style="text-align: left;">Blocking Client</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>&gt; BRPOP my-q 0</code><br>待機</td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: left;"><code>&gt; LPUSH my-q hello</code><br><code>(integer) 1</code></td>
<td style="text-align: left;"><code>1) "my-q"</code><br><code>2) "hello"</code><br>コマンド受付</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>&gt; BRPOP my-q 0</code><br>待機</td>
</tr>
</tbody>
</table>
<p>1行目では，リスト（"my-q"）に値がないため，ブロッキングクライアントがすぐに何も返さないことがわかります．最後の引数はタイムアウトで，この場合ゼロはタイムアウトせず，永遠に待つことを意味します．
2行目では，送信側のクライアントがmy-qキーにLPUSHを発行し，すぐに他のクライアントでのブロックが終了します．
3行目では，別のBRPOPコマンドを発行して(通常はクライアント言語のループで実現します)，さらなるリスト値を待つことができます．redis-cli では ctrl-c でブロッキングを解除できます．</p>
<p>この例を逆にして，空でないリストで BRPOP がどう動くか見てみましょう．</p>
<table>
<thead>
<tr>
<th style="text-align: left;">R</th>
<th style="text-align: left;">Sending Client</th>
<th style="text-align: left;">Blocking Client</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;"><code>&gt; LPUSH my-q hello</code><br><code>(integer) 1</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: left;"><code>&gt; LPUSH my-q hej</code><br><code>(integer) 2</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: left;"><code>&gt; LPUSH my-q bonjour</code><br><code>(integer) 3</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>&gt; BRPOP my-q 0</code><br><code>1) "my-q"</code><br><code>2) "hello"</code></td>
</tr>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>&gt; BRPOP my-q 0</code><br><code>1) "my-q"</code><br><code>2) "hej"</code></td>
</tr>
<tr>
<td style="text-align: left;">6</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>&gt; BRPOP my-q 0</code><br><code>1) "my-q"</code><br><code>2) "bonjour"</code></td>
</tr>
<tr>
<td style="text-align: left;">7</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>&gt; BRPOP my-q 0</code><br>待機</td>
</tr>
</tbody>
</table>
<p>1〜3行目では，3つの値をリストにプッシュし，レスポンスが大きくなっているのがわかります（リスト内のアイテム数を表しています）．
4行目は，BRPOPコマンドを発行したにもかかわらず，すぐに値を返していますね．なぜかというと，ブロック動作はキューに項目がない場合にのみ適用されるからです．
5〜6行目でも同じように即座に応答しているのがわかりますが，これはキュー内の各項目を通過しているためです．
7 行目では，BRPOP は空のキューに遭遇し，キューにアイテムが追加されるまでブロックしています．</p>
<p>キューはしばしば，他のプロセス（ワーカー）で達成されなければならないジョブのリストを表します．この種の作業負荷で重要なのは，ワーカーが処理中に何らかの理由で故障して死んでも，ジョブが失われないということです．
Redisはこのタイプのキューもサポートすることができます．BRPOP を使用する代わりに，BRPOPLPUSH で代用してください．BRPOPLPUSHは（長すぎ！）は，あるリストで値を待ち，一旦値を得たら，それを別のリストにプッシュします．これはすべてアトミックに実行されるので，2つのワーカーが同じ値を削除したり取得したりすることはできません．では，どのように動作するか見てみましょう．</p>
<table>
<thead>
<tr>
<th style="text-align: left;">R</th>
<th style="text-align: left;">Sending Client</th>
<th style="text-align: left;">Blocking Client</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>&gt; LINDEX worker-q 0</code><br><code>(nil)</code></td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1行目の結果がnilでない場合，それを使って何かする．そうでない場合は4にジャンプする</td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>&gt; LREM  worker-q -1 [value from 1]</code><br><code>(integer) 1</code><br>1へ戻る</td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>&gt; BRPOPLPUSH my-q worker-q 0</code><br>待機</td>
</tr>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: left;"><code>&gt; LPUSH my-q hello</code></td>
<td style="text-align: left;"><code>"hello"</code><br><code>コマンド受付</code></td>
</tr>
<tr>
<td style="text-align: left;">6</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>hello</code>で何かする</td>
</tr>
<tr>
<td style="text-align: left;">7</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>&gt; LREM worker-q -1 hello</code><br><code>(integer) 1</code></td>
</tr>
<tr>
<td style="text-align: left;">8</td>
<td style="text-align: left;"></td>
<td style="text-align: left;">1へ戻る</td>
</tr>
</tbody>
</table>
<p>1行目と2行目では，worker-qが空なのでまだ何もしていません．もし woker-q から何か出てきたら，それを処理して取り除き，それから 1 にジャンプしてキューに何かないか確認することになります．この方法では，まずワーカーキューをクリアして，すでにあるジョブを実行することになります．
4行目では，my-qに値が追加されるまで待ち，値を取得したらアトミックにworker-qに追加しています．次に，"hello" に対して何らかの非 Redis 操作を行い，それが終わったら LREM を使って Worker-q からインスタンスを 1 つ削除し，1 行目に戻ってループしています．</p>
<p>重要なのは，6行目の処理中にプロセスが停止しても，worker-q にこのジョブが残っていることです．プロセスが再起動したら，7行目までに削除されていないジョブを即座にクリアします．</p>
<p>このパターンにより，ジョブが失われる可能性は大幅に減少します．ただし，ワーカーが 2 行と 3 行，または 5 行と 6 行の「間」で死んだ場合のみ，ジョブが 2 回処理される可能性があります．</p>
<p>これはありえないことですが，ワーカーロジックでこの状況を考慮することは，ベストプラクティスと言えるでしょう．</p>
<h2>Redlock</h2>
<p>システムにおいて，リソースをロックしなければならない場合があります．これは，同時に解決できない重要な変更を行うためかもしれません．ロックの目標は次のとおりです．</p>
<ul>
<li>1人のワーカー（そして1人だけ）がリソースの権利を取得できるようにすること</li>
<li>このロックを確実に解除できること</li>
<li>リソースがデッドロックにならないこと．つまり，リソースは一定時間後にロックが解除される必要があります．</li>
</ul>
<p>Redisはシンプルなキーベースのデータモデルを持ち，各シャードがシングルスレッドであり，非常に高速であるため，ロックするのに良い選択肢です．Redisを使ったロックの実装は，Redlockと呼ばれる標準的なものが確立されています．</p>
<p>Redlockのクライアントはほとんどすべての言語で利用可能なので，車輪の再発明は必要ありません．しかし，Redlockを安全かつ効果的に使うためには，Redlockの仕組みを理解することが重要です．</p>
<p>まず，Redlockは独立したRedisインスタンスを持つ最低3台のマシン上で動作するように設計されていることを理解することが重要です．これにより，ロック機構に単一障害点が発生することを避けることができます（すべてのリソースでデッドロックが発生することになります！）．例えば，マシンAの1秒はマシンBの1秒と同じように正確に同じ速度で時間が進みます．</p>
<p>Redlockでロックを設定するには，まずタイムスタンプをミリ秒の精度で取得し，あらかじめロック時間を決めておく必要があります．次に，ランダムな値を持つキーをSETし（キーがまだ存在しない場合のみ），さらにそのキーにタイムアウトを設定することでロックをかけます．これを独立したインスタンスごとに直列に繰り返す．インスタンスがダウンしている場合は，すぐに次のインスタンスに移動します．与えられたタイムアウトの前に，大多数のインスタンスでロックが正常に設定された場合，ロックが取得されます．時間内にロックが設定されなかった場合，ロックは設定されない．ロック操作または更新に要する時間は，ロック達成に要した時間から予め設定された総ロック時間を差し引いたものである．失敗またはタイムアウトの場合，すべてのインスタンスのロックを解除して再試行する．</p>
<p>ロックを解除するには，Luaスクリプトを使用して，キーセットが期待されるランダムな値を持っているかどうかをチェックします．もしそうであれば，そのキーを削除し，そうでなければ，より新しいロックである可能性があるので，そのままにしておきます．</p>
<p>Redlock処理では，単一障害点がないことを保証しています．そのため，単一のロックが分配され，デッドロックが発生しないことを強く確信することができます．</p>
<h2>Pub/Sub</h2>
<p>データストレージの他に，RedisはPublisher/Subscriberプラットフォームとして使用することができます．このパターンでは，パブリッシャーはチャンネル上の任意の数のサブスクライバーにメッセージを発行することができます．これらのメッセージは fire-and-forget で，メッセージが発行されても購読者が存在しなければ，メッセージは蒸発し，回復することができなくなります．</p>
<p>一度チャンネルに登録すると，クライアントはサブスクライバーモードになり，クライアントからコマンドを発行することができなくなります．このように，クライアントは読み取り専用になります．パブリッシングには，このような制限はありません．</p>
<p>一度に複数のチャンネルを購読することができます．まず，SUBSCRIBE コマンドを使用して，weather と sports の 2 つのチャンネルを購読してみましょう．</p>
<p>```</p>
<blockquote>
<p>SUBSCRIBE weather sports
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "weather"
3) (integer) 1
1) "subscribe"
2) "sports"
3) (integer) 2
```
別のクライアント（この例では別の端末）で，これらのチャンネルのいずれかにアイテムを公開することができます．PUBLISHコマンドを実行することでこれを行います．</p>
</blockquote>
<p>```</p>
<blockquote>
<p>PUBLISH sports oilers/7:leafs/1
(integer) 1
```
第一引数はチャンネル，第二引数はメッセージです．メッセージは何でもよく，この場合はエンコードされたスポーツのスコアです．これは，配信されるクライアントの数を返します．サブスクライバーモードのクライアントに戻ると，すぐにメッセージが表示されます．</p>
</blockquote>
<p><code>1) "message"
2) "sports"
3) "oilers/7:leafs/1"</code>
このレスポンスには3つの要素があります．メッセージである通知，チャンネル，そして最後にメッセージそのものです．クライアントはメッセージを受信した後，すぐにリスニングに戻ります．もう一方に戻ると，別のメッセージを発行することができます．</p>
<p>```</p>
<blockquote>
<p>PUBLISH weather snow/-4c
(integer) 1
```
もう一方のクライアントでは，同じフォーマットで，別のチャンネルとイベントが表示されます．</p>
</blockquote>
<p><code>1) "message"
2) "weather"
3) "snow/-4c"</code>
誰も購読していないチャンネルに発行してみましょう．</p>
<p>```</p>
<blockquote>
<p>PUBLISH currency CADUSD/0.787
(integer) 0
```
通貨チャンネルをリッスンしているクライアントがいないので，返り値は 0 です．このメッセージはこれで消えてしまい，その後通貨チャンネルを購読するクライアントにはこのメッセージは通知されません - メッセージが発行されたことも，それがどのように忘れ去られたかもわかりません．</p>
</blockquote>
<p>個々のチャンネルへのサブスクライブとは別に，Redis ではパターンベースのサブスクリプションも可能です．グロブスタイルのパターンと，PSUBSCRIBEコマンドで有効になります．</p>
<p>```</p>
<blockquote>
<p>PSUBSCRIBE sports:<em>
```
これは，"sports:</em>" で始まるすべてのチャネルのメッセージを取得します．もう一方のクライアントで，次のコマンドを実行します．</p>
</blockquote>
<p>```</p>
<blockquote>
<p>PUBLISH sports:hockey oilers/7:leafs/1
(integer) 1
PUBLISH sports:basketball raptors/33:pacers/7
(integer) 1
PUBLISH weather:edmonton snow/-4c
(integer) 0
```
最初の2つのコマンドは1を返し，最後のコマンドは0を返していることに注目してください．sports:hockeyやsports:basketの直接の購読者がいなくても，パターンの購読によって受信されたものとしてピックアップされます．サブスクライブしたクライアントに戻ると，パターンにマッチしたチャンネルのみが結果を返していることがわかります．</p>
</blockquote>
<p><code>1) "pmessage"
2) "sports:*"
3) "sports:hockey"
4) "oilers/7:leafs/1"
1) "pmessage"
2) "sports:*"
3) "sports:basketball"</code>
このレスポンスは，マッチしたパターン(2)と実際のチャンネル名(3)の両方を持っているので，まっすぐなSUBSCRIBEレスポンスとは少し異なります．</p>
<h2>分散イベント</h2>
<p>RedisのPub/Subメッセージングを拡張することで，興味深い分散イベントを作成することができます．例えば，ハッシュに格納された構造体があるとして，特定のフィールドがサブスクライバーによって定義された数値を超えたときだけ，そのクライアントを更新したいとしましょう．チャネルのパターンをリッスンし，その時だけ，ステータスでハッシュを捕まえることにします．この例では，update_statusが5から9の間であるときのみ，興味があります．</p>
<p>```</p>
<blockquote>
<p>PSUBSCRIBE update_status:[5-9]
1) "psubscribe"
2) "update_status:[5-9]"
3) (integer) 1
待機
```
status/error_levelの値を変更するために，2つのコマンドを順次またはMULTI/EXECブロック内で実行するサブルーチンを用意することにします．最初のコマンドはレベルを設定し，2番目のコマンドはチャネル自体に値をエンコードして通知を発行します．</p>
</blockquote>
<p>```</p>
<blockquote>
<p>HSET status error_level 5
(integer) 1
PUBLISH update_status:5 0
(integer) 1
```
メッセージを受信すると，クライアントアプリケーションは代替クライアントに切り替わり，HGETALLコマンドを発行します．</p>
</blockquote>
<p>```</p>
<blockquote>
<p>HGETALL status
1) "error_level"
2) "5"
3) "last_error"
4) "Crawler returned 404"
5) "timestamp"
6) "1511467605734"
```
これを利用して，例えば，長時間稼働しているプロセスのローカル変数を更新することができます．これによって，同じプロセスの複数のインスタンスがライブでデータを「共有」することができます．</p>
</blockquote>
<p>このパターンとPub/Subの組み合わせの良いところは，プロセスが再起動したときに，単にステータスハッシュ全体を取得してリッスンを開始できるところです．そして，その変更はいくつものプロセス間で同期されます．インスタンスがRedisサーバから切断された場合，再接続の一部として，サーバはステータスのハッシュを取得し，リッスンを再開することができます．</p>
<h1>データストレージ・パターン</h1>
<p>Redisは主にストレージエンジンですが，データを構造体に入れて再び取り出すということ以上のパターンがいくつかあります．このセクションでは，構造体を直接使うようなものは省き，特別な準備が必要なパターンや，自明でないパターンに焦点を当てました．</p>
<h2>JSONストレージ</h2>
<p>RedisにJSONを保存するには，いくつかのオプションが存在します．最も基本的な形式は，事前にシリアライズされたものを，単に特定のキーに格納することです．
```</p>
<blockquote>
<p>SET car "{"colour":"blue","make":"saab","model":93,"features":["powerlocks","moonroof"]}"
OK
GET car
"{"colour":"blue","make":"saab","model":93,"features":["powerlocks","moonroof"]}"
```
これは，一見単純に見えますが非常に大きな欠点があります．</p>
</blockquote>
<p>シリアライゼーションは，読み取りと書き込みの際にクライアントの計算機資源を消費します．
JSON形式は，データサイズを増加させます．
Redisには，実際のJSONデータを操作する間接的な方法があるだけです．
最初の2，3点は，少量のデータでは無視できるかもしれませんが，間違いなく積み重なる可能性があります．特に，数メガバイトのJSONを保存している場合はそうです．しかし，3つ目のポイントはより重要です．</p>
<p>Redis 4.0以前は，Redis内部でJSONデータを扱うには，cjsonモジュールを通じてLuaスクリプトを使用する方法しかありませんでした．これはJSONの問題を部分的に解決するものでしたが，それでもボトルネックとなり，Luaの学習という余分な負担を増やすことになりました．</p>
<p>さらに悪いことに，多くのアプリケーションは，JSON文字列全体をGETしてデシリアライズし，それを操作して再シリアライズし，アプリケーションで再びSETしていました．これはアンチパターンです．この方法では，データを失う危険性が非常に高いのです．例えば</p>
<p>:::message alert
<strong>アンチパターン：使ってはいけない</strong>
|#|Application Instance #1|Application Instance #2|
|:--|:--|:--|
|1|<code>&gt; GET my-car</code>||
|2|デシリアライズし，色を'赤'に変えて再シリアライズする|<code>&gt; GET my-car</code>|
|3|<code>&gt; SET my-car [Instance #1の新規の値]</code>|デシリアライズし，モデルを'95'に変更し，再シリアライズする|
|4||<code>&gt; SET my-car [Instance #2の新規の値]</code>|
|5||<code>&gt; GET my-car</code>|
:::</p>
<p>5行目の結果では，インスタンス#2からの更新のみが表示され，インスタンス#1での色の設定は失われることになります．</p>
<p>Redis 4.0+では，モジュールを使用する機能があります．RedisJSONは，特殊なデータ型と直接操作のコマンドを提供するモジュールです．RedisJSONはデータをバイナリ形式で保存し，JSONからストレージのオーバーヘッドを取り除き，再シリアライズすることなく要素に素早くアクセスできるようにします．</p>
<p>RedisJSONを使用するには，Redisサーバーにインストールするか，Redis Enterpriseデータベースで有効にする必要があります．</p>
<p>先ほどの例で，JSONを文字列として保存する代わりにRedisJSONを使用すると，次のようになります．</p>
<p>:::message
<strong>より良いパターン</strong>
|#|Application Instance #1|Application Instance #2|
|:--|:--|:--|
|1|<code>&gt; JSON.SET car2 . '{"colour":"blue", "make":"saab", "model":93, "features" :[ "powerlocks", "moonroof" ]}'</code>||
|2|<code>&gt; JSON.SET car2 colour '"red"'</code>||
|3||<code>&gt; JSON.SET car2 model '95'</code>|
|4||<code>&gt; JSON.GET car2 . "{ "colour":"red", "make":"saab", "model":95, "features": ["powerlocks", "moonroof"]}"</code>|
:::</p>
<p>RedisJSONは，データストア内のJSONを操作するための，より安全で高速，かつ直感的な方法を提供します（特にサブ要素のアトミックな操作が必要な場合）．</p>
<h2>オブジェクト→ハッシュ ストレージ</h2>
<p>Redisのネイティブデータ型hash(map)は，一見するとJSONオブジェクトや他のレコードデータ型に非常に似ているように見えるかもしれません．実際にはもっと単純で，各フィールドは文字列か数値のどちらかだけで，サブフィールドは使えません．しかし，各フィールドの「パス」をあらかじめ計算しておくことで，オブジェクトをフラットにしてRedis Hashmapに格納することができます．</p>
<p>この例を見てみましょう．
<code>json
{
    "colour":"blue",
    "make":"saab",
    "model":{
       "trim" : "aero",
       "name" : 93
    },
    "features":[ "powerlocks", "moonroof" ]
}</code>
JSONPathを使うと，各項目をハッシュマップで1階層に表現することができます．
```</p>
<blockquote>
<p>HSET car3 colour blue
HSET car3 make saab
HSET car3 model.trim aero
HSET car3 model.name 93
HSET car3 features[0] powerlocks
HSET car3 features[1] moonroof
<code>（わかりやすくするために個々のコマンドで表示しています．スクリプトでは HSET を多様に使用することになります）
これは，オブジェクト全体を取得することができる方法です．</code>
HGETALL car3
 1) "colour"
 2) "blue"
 3) "make"
 4) "saab"
 5) "model.trim"
 6) "aero"
 7) "model.name"
 8) "93"
 9) "features[0]"
10) "powerlocks"
11) "features[1]"
12) "moonroof"
<code>またはオブジェクトの個々の部分に対して取得するには</code>
HGET car3 model.trim
"aero"
```
この方法は，Redisのストアオブジェクトにアクセスするための迅速で便利な方法を提供できますが，欠点もあります．
 - 言語やライブラリによって，JSONPathの実装が微妙に異なり，非互換性が生じる可能性があります．このため，シリアライズとデシリアライズは同じライブラリで行う必要があります．
 - 配列のサポートが不安定な場合があります
   - 疎な配列は問題があります
   - 配列の途中に項目を挿入するような多くの操作ができません
 - JSONPathのキーに不要なオーバーヘッドがある</p>
</blockquote>
<p>このパターンは，ReJSONと重なる部分が多くあります．もしReJSONが利用できるのであれば，そちらの方が良い選択であることが非常に多いです．この方法でオブジェクトを保存すると，Redisの別のコマンドと統合されるというReJSONの利点があります．SORTです．しかし，SORTコマンドは複雑なトピックであり（このパターンの範囲外です），計算も複雑なので，慎重に管理しないとうまくスケールしない方法で使われる可能性があります．</p>
<h1>時系列パターン</h1>
<p>時系列データ，または自然な時間的順序を持つデータは，データと希望するアクセスパターンに応じて，Redisでいくつかの方法でモデル化することができます．ここでは，いくつかのパターンを見ていきます．</p>
<h2>ソート済みセット時系列データ</h2>
<p>ソート済みセット（ZSET）を用いた時系列は，Redisで時系列データをモデル化する典型的な方法です．Sorted Setsはスコアを持つユニークなメンバーで構成され，すべて一つのキーの下に保存されます．このデータ型をソート済みセットに使うということは，スコアがある種の時間の指標（常にではありませんが，多くの場合ミリ秒精度のタイムスタンプ）として働き，メンバーが記録されたデータであることを意味します．ただし，これはセットの一種であるため，一意のメンバーのみが許可され，前のメンバーと同じ値を持つ時系列のエントリを記録しようとすると，スコアだけが更新される結果になります．この問題を説明するために，時間の経過とともに温度を記録する次のような例を挙げます．</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Timestamp</th>
<th style="text-align: left;">Temperature C</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">1511533205001</td>
<td style="text-align: left;">21</td>
</tr>
<tr>
<td style="text-align: left;">1511533206001</td>
<td style="text-align: left;">22</td>
</tr>
<tr>
<td style="text-align: left;">1511533207001</td>
<td style="text-align: left;">21</td>
</tr>
</tbody>
</table>
<p>これをZADDで直接ソート済みセットとして追加しただけでは，いくつかのデータポイントを見落とすことになります．</p>
<p>:::message alert
<strong>アンチパターン</strong>
```</p>
<blockquote>
<p>ZADD temperature 1511533205001 21
(integer) 1
ZADD temperature 1511533206001 22
(integer) 1
ZADD temperature 1511533207001 21
(integer) 0
ZRANGEBYSCORE temperature -inf +inf WITHSCORES
1) "22"
2) "1511533206001"
3) "21"
4) "1511533207001"
```
:::</p>
</blockquote>
<p>3番目のZADDが0を返していることに注目してください．これは，ソート済みセットに新しいメンバーが追加されていないことを示します．次に ZRANGEBYSCORE を見ると，ソート済みセットには ...7001 と ...6001 の 2 つのエントリしかなく， ...5001 がないことがわかります．なぜでしょうか？この場合，...7001 と ...5001 は同じメンバ (21) を共有しているので，メンバのスコアのみを更新しました．よくありません．</p>
<p>この問題に対処するには，いくつかの方法があります．その一つは，一意性を確保するために十分なエントロピーを持つある種のランダムなデータを含めることです．
この方法を検討してみましょう．まず，0（包括的）から1（排他的）の間の擬似乱数浮動小数点数を作成し，これをタイムスタンプに追加します．この例では，読みやすくするために10進数のままにしておきます（実際のワークロードでは，ストレージスペースを節約するために生の8バイトに変換するのが賢明でしょう）．</p>
<p>```</p>
<blockquote>
<p>ZADD temperature2 1511533205001 21:1511533205001.2583
(integer) 1
ZADD temperature2 1511533206001 22:1511533206001.941678
(integer) 1
ZADD temperature2 1511533207001 21:1511533207001.732015
(integer) 1
ZRANGEBYSCORE temperature2 -inf +inf WITHSCORES
1) "21:1511533205001.2583"
2) "1511533205001"
3) "22:1511533206001.941678"
4) "1511533206001"
5) "21:1511533207001.732015"
6) "1511533207001"
```
ご覧のように，すべてのZADDは新しい追加を示す1を返し，ZRANGEBYSCOREはすべての値を返します．これは実行可能な方法ですが，一意性を確保するために無駄なバイトが発生し，ストレージのオーバーヘッドを増加させるため，あまり効率的ではありません．ほとんどの使用例では，一意性はアプリケーションによって破棄されるだけです．データがすでに一意である場合（たとえば，UUIDを含むデータなど），一意性の追加は明らかに不要であることに注意する必要があります．</p>
</blockquote>
<p>このメソッドでは，ソートされた集合のすべてのメソッドにアクセスでき，分析や操作を行うことができます．</p>
<ul>
<li>ZRANGEBYSCORE を使用すると，2 つのタイムスタンプの間の特定のスライスを取得することができます．(降順の場合はZREVRANGEBYSCORE)</li>
<li>ZREMRANGEBYSCOREにより，タイムスタンプの特定範囲を削除することができる</li>
<li>ZCOUNT あるタイムスタンプの範囲にあるアイテムの個数</li>
<li>ZINTERSTORE<a href="ZINTERSTOREとZUNIONSTOREはマルチキー操作です．シャード環境で作業する場合は，新しいキーが同じシャード上で終了するように注意する必要があります．">^1</a> 2つの時系列データセットを交差させ，新しいキーに保存することができる</li>
<li>ZUNIONSTORE<a href="ZINTERSTOREとZUNIONSTOREはマルチキー操作です．シャード環境で作業する場合は，新しいキーが同じシャード上で終了するように注意する必要があります．">^1</a> により，2 つの時系列データセットを結合し，新しいキーに保存することができます．また，並べ替えられたセットを複製するのにも使用できます．</li>
</ul>
<h2>ソート済みセット字句データ</h2>
<p>時系列を扱うもう一つの方法は，ソート済みセットの辞書的特性を利用して，タイムスタンプと値を保存することです．もし辞書式エンコーディングについてのセクションを読んでいないなら，今がいい機会でしょう．</p>
<p>事実上，この方法ではすべてを同じスコア（通常は0）で保存し，最初にタイムスタンプを，次に値をメンバーとしてエンコードしています．この例を見てみましょう．</p>
<p>```</p>
<blockquote>
<p>ZADD lex-temperature 0 1511533205001:21
(integer) 1
ZADD lex-temperature 0 1511533206001:22
(integer) 1
ZADD lex-temperature 0 1511533207001:21
(integer) 1
ZRANGE lex-temperature 0 -1
1) "1511533205001:21"
2) "1511533206001:22"
3) "1511533207001:21"
```
(いつものように，タイムスタンプをより高い基数で表現して，数バイトを節約することができます)</p>
</blockquote>
<p>3つのZADDコマンドでは，タイムスタンプと値がコロンで区切られており，3つとも追加されたことを示す1が返されていることがわかります．最後のコマンドZRANGEでは，順番が維持されていることがわかります．なぜでしょうか？
ソート済みセットでは，スコアが等しい場合，同じスコアを持つ結果はバイナリソートで並べられます．現在の時間帯のタイムスタンプはすべて同じ桁数なので，すべてがきれいにソートされます（タイムスタンプが2002年以前や2285年以降になる場合は，パディング桁を追加する必要があります）．</p>
<p>この方法では，重複を防ぐための一意性の追加には依存しませんが，同じミリ秒に同じ値を持つ複数の項目が記録されないという別の欠点があります．これは，あなたのユースケースにとって問題かもしれないし，そうでないかもしれない．実際には，ほとんどの状況でミリ秒の解像度で十分であることが証明されています．</p>
<p>このタイプの時系列モデルから値の範囲を取得するには，ZRANGEBYLEXコマンドを使用します．例えば，タイムスタンプ1511533200001以降の気温を取得したいとします．</p>
<p>```</p>
<blockquote>
<p>ZRANGEBYLEX lex-temperature (1511533200001 +
1) "1511533205001:21"
2) "1511533206001:22"
3) "1511533207001:21"
```
第2引数は，実際の値とは排他的であることを示すために開括弧を前置します（包含は開角括弧で表しま）．実際には，タイムスタンプの後に必ず付加的なデータが続くため，上記の書式では包括的，排他的は関係ありません．第3引数(+)は，上限を設けないことを示します．</p>
</blockquote>
<p>ここで，直感に反するような問題を考えてみましょう．1511533200001と1511533207001の間のデータを取得しようとするこのコードを見てみます．</p>
<p>```</p>
<blockquote>
<p>ZRANGEBYLEX lex-temperature [1511533200001 [1511533207001
1) "1511533205001:21"
2) "1511533206001:22"
```</p>
</blockquote>
<p>なぜ，タイムスタンプ1511533207001のデータは，包括的な接頭辞を付けているにもかかわらず除外されたのでしょうか？
Redisはこれがタイムスタンプであることを理解していると思いたいところですが，実はそうではなく，Redisはバイナリソートを見ているだけなのです．バイナリソートでは，「1511533207001:21」は「1511533207001」よりも包括的，排他的に大きいのです．上界を包含する正しい方法は，目的の上界から1ミリ秒上に行き，排他的記法を使うことです．</p>
<p>```</p>
<blockquote>
<p>ZRANGEBYLEX lex-temperature [1511533200001 (1511533207002
1) "1511533205001:21"
2) "1511533206001:22"
3) "1511533207001:21"
```
字句のソートセット時系列データには，通常のソートセット時系列データと同様の便利なコマンド群があります．</p>
</blockquote>
<ul>
<li>ZRANGEBYLEX / ZREVRANGEBYLEX 値の範囲を昇順または降順で（それぞれ）取得</li>
<li>ZREMRANGEBYLEX ソートによる特定の範囲の値の削除</li>
<li>ZLEXCOUNT ソートによる値の範囲の間の項目のカウントを取得
ZINTERSTORE と ZUNIONSTORE は辞書式ソートのセットに対して使用できますが，タイムスタンプと値の組み合わせが重複すると，データ中に重複が発生しないため，データポイントを失うリスクがあります．</li>
</ul>
<p>なぜタイムスタンプスコアと辞書式ソートセットエンコーディングのソートセットを選ぶのか，不思議に思われるかもしれません．通常，値が常に一意でない限り，時系列には辞書式ソートセットを使用した方が効率的です．</p>
<h2>ビットフィールドを持つ時系列データ</h2>
<p>純粋に正規化された数値データを保存するのであれば，Redisは非常に効率的にビットフィールドに時系列データを保存することができます．データを格納するためには，まず，任意のエポックタイム，解像度，数値フォーマットを決定する必要があります．温度データを取り込む例で考えてみましょう．1分に1回温度を取りたいので，ある日の午前0時をエポックに設定するとします．また，室内の気温を摂氏で計測するとする．</p>
<p>そうすると，次のようなデータ構成になります．</p>
<p>その日の午前0時＝バイト0
温度は8ビットの符号なし整数（0～255）で記録されます
これで1日分のデータが約1.44KBになります</p>
<p>BITFIELDコマンドで気温を記録することができるのです．
```</p>
<blockquote>
<p>BITFIELD bit-ts SET u8 #0 22
1) (integer) 0
```</p>
</blockquote>
<p>この場合，キーとなるbit-tsに符号なし8ビット（u8）で0時（#0），温度は22で記録しています．ビットフィールドは符号なし8ビットの値に限らず，実際には1ビットから符号なし63ビット，符号あり64ビットまで操作することが可能です．オフセット(#0)の前にあるハッシュに注意してください．例えば，#79を指定した場合，79バイト入っていることを意味し，ハッシュを省けば79ビット目を意味する．</p>
<p>例えば，午前1時を記録する場合，0から始まるスロットを考慮すると，#59のオフセットを使用し，#719のオフセットでは正午を記録することになる．</p>
<p>```</p>
<blockquote>
<p>BITFIELD bit-ts SET u8 #59 23 SET u8 #719 25
1) (integer) 0
2) (integer) 0
```
これは，BITFIELDが可変であり，一度に複数の値を追加できることを表しています．</p>
</blockquote>
<p>時系列にもう少し値を追加してみましょう．
```</p>
<blockquote>
<p>BITFIELD bit-ts SET u8 #60 21 SET u8 #61 20
1) (integer) 0
2) (integer) 0
<code>では，それらの値を取り出してみましょう．</code>
BITFIELD bit-ts GET u8 #59 GET u8 #60 GET u8 #61
1) (integer) 23
2) (integer) 21
3) (integer) 20
```
BITFIELDのサブコマンドGETは，第3引数に値を受け取らない以外は，SETと同じような書式です．</p>
</blockquote>
<p>取得する必要のあるインデックスがすべてわかっている場合は良いのですが，値の範囲が必要な場合もあり，各バイトを個別に指定するのは大変です．GETRANGEコマンドを使えばいいのです．通常，これは文字列からバイトを取得するために使用されますが，BITFIELDは同じ基礎データをアドレス指定する別の方法に過ぎません．
```</p>
<blockquote>
<p>GETRANGE bit-ts 59 61
"x17x15x14"
```
これで59〜61バイトが16進数で返されました（10進数では23,21,20）．言語クライアントはredis-cliよりもバイナリデータの扱いに長けており，通常はその言語の慣用的なバイト配列を取得することができます．</p>
</blockquote>
<p>この例では，0, 59-61, 719 バイトを操作しています．もしまだ設定していないバイトを要求したらどうなるでしょうか？見てみましょう．
```</p>
<blockquote>
<p>BITFIELD bit-ts GET u8 #40
1) (integer) 0
BITFIELD bit-ts GET u8 #750
1) (integer) 0
GETRANGE bit-ts 30 50
"x00x00x00x00x00x00x00x00x00x00x00x00x00x00x00x00x00x00x00x00x00"
```
これは，時系列データを扱う際に厄介なことです．アプリケーションロジックは，0と未設定の値を区別する必要があります．特に符号付き整数を使用する場合は，この値が範囲の中央にある正当な値である可能性があるため，ある種の人工的な床や0として設定された値のスキップが必要になる場合があります．</p>
</blockquote>
<p>実際に保存される時系列の長さは，設定された最後のバイトに依存します．つまり，この例では，格納された最後のバイトは719バイト目（ゼロベース）なので，データの長さは720バイトになります．これをSTRLENで確認することができます．
```</p>
<blockquote>
<p>STRLEN bit-ts
(integer) 720
```
BITFIELDベースの時系列は，数値やバイナリデータを格納するための強力かつコンパクトなパターンです．しかし，このソリューションはすべてのユースケースに適合するわけではないので，特定のニーズに適合するかどうかを慎重に評価する必要があります．</p>
</blockquote>
<h1>レートリミット・パターンの基礎</h1>
<p>Redisでレートリミッターを構築するのは，INCRとEXPIREの2つのコマンドのおかげで簡単です．基本的なコンセプトは，ある期間内に特定のサービスに対するリクエストを制限したい，というものです．例えば，APIキーでユーザーを特定するサービスがあるとします．このサービスは，任意の1分間に20リクエストに制限されていることを述べています．</p>
<p>これを実現するために，APIキーごとに1分ごとにRedisキーを作成したいと思います．データベース全体がゴミでいっぱいにならないように，そのキーも1分後に失効させる．このように可視化します．</p>
<p>User API Key = zA21X31，標準字体が無制限，斜体が制限を表しています．</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Redis Key</th>
<th style="text-align: left;">zA21X31:0</th>
<th style="text-align: left;">zA21X31:1</th>
<th style="text-align: left;"><em>zA21X31:2</em></th>
<th style="text-align: left;">zA21X31:3</th>
<th style="text-align: left;"><em>zA21X31:4</em></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Value</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;"><em>20</em></td>
<td style="text-align: left;">&gt;2</td>
<td style="text-align: left;"><em>20</em></td>
</tr>
<tr>
<td style="text-align: left;">Expires at</td>
<td style="text-align: left;">Latest 12:02</td>
<td style="text-align: left;">Latest 12:03</td>
<td style="text-align: left;"><em>Latest 12:04</em></td>
<td style="text-align: left;">Latest 12:05</td>
<td style="text-align: left;"><em>Latest 12:06</em></td>
</tr>
<tr>
<td style="text-align: left;">Time</td>
<td style="text-align: left;">12:00</td>
<td style="text-align: left;">12:01</td>
<td style="text-align: left;"><em>12:02</em></td>
<td style="text-align: left;">12:03</td>
<td style="text-align: left;"><em>12:04</em></td>
</tr>
</tbody>
</table>
<p>キーは，User APIキーに分数をコロンで連結したものです．キーは常に期限切れになるので，分単位で記録しておきます．時間が59分から00分になったとき，もう59分は存在しないことが確認できます（58分前に期限切れになります）．</p>
<p>擬似コードで，これがどのように機能するかを見てみましょう．
 1. <code>&gt; GET [user-api-key]:[current minute number]</code>
 3. 1行目の結果が20未満（または未設定）の場合は4へ，それ以外の場合は3へ進みます
 4. エラーメッセージを表示し，接続を切断します．全体を終了します．
 5. <code>&gt; MULTI
    OK
    &gt; INCR [user-api-key]:[current minute number]
    QUEUED
    &gt; EXPIRE [user-api-key]:[current minute number] 59
    QUEUED
    &gt; EXEC
    OK</code>
このルーチンで理解すべきポイントは2つあります．</p>
<ul>
<li>存在しないキーの INCR は常に 1 になります．つまり，このルーチンの最初の呼び出しは1という値になります．</li>
<li>EXPIREはINCRと一緒にMULTIトランザクションの中にあり，これは単一のアトミック操作を形成することを意味します．</li>
</ul>
<p>:::message alert
最悪の場合，INCRとEXPIREの間にRedisサーバーが停止してしまうことがあります．AOFまたはインメモリレプリケーションからリストアする場合，トランザクションが完了していないため，INCRはリストアされません．
:::</p>
<p>このパターンでは，1人のユーザーが2つの制限鍵を持つ可能性があります．1つは現在使用中で，もう1つは同じ分数ウィンドウの間に期限切れとなりますが，それ以外は非常に効率的です．</p>
<h1>ブルームフィルター・パターン</h1>
<p><a href="https://ja.wikipedia.org/wiki/%E3%83%96%E3%83%AB%E3%83%BC%E3%83%A0%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF">ブルームフィルタ</a>は，ある項目が過去に一度も追加されていないかどうかを確認するために使用できる，興味深い確率的データ構造です．この不思議な言い回しは意図的なものです．偽陽性はあり得るが偽陰性はあり得ないという意味で，確率的なのです．ブルームフィルタは，すべてのアイテムをセットに格納してSISMEMBERを呼び出すよりもはるかにコンパクトで高速な方法で，すばやく存在チェックを行うことができます．</p>
<p>ブルームフィルタはアイテムをハッシュ関数に通し，そのハッシュからビットをサンプリングしてビットフィールドに特定の間隔で0から1をセットすることで動作します．ブルームフィルタの存在を確認するために，同じビットがサンプリングされます．多くの項目はビットが重複している可能性がありますが，ハッシュ関数は一意な識別子を生成するので，ハッシュの1ビットが0であれば，それは以前に追加されていないことが分かります．</p>
<p>ブルームフィルタは，GETBITとSETBITを利用してキーのビットフィールドを扱うクライアントサイドライブラリを通じて，何年も前からRedisで使用されています．しかし，Redis 4.0以降，ReBloomモジュールが利用可能になり，ブルームフィルタの実装のオーバーヘッドを取り除くことができるようになりました．</p>
<p>ブルームフィルタの良い使用例としては，既に使用されているユーザー名をチェックすることです．小規模であれば問題ないのですが，サービスが大きくなると，これはデータベースにとって非常に大きな負担となります．これをReBloomで実装するのはとても簡単です．</p>
<p>まず，テストとして一握りのユーザーネームを追加してみましょう．
```</p>
<blockquote>
<p>BF.ADD usernames funnyfred
(integer) 1
BF.ADD usernames fredisfunny
(integer) 1
BF.ADD usernames fred
(integer) 1
BF.ADD usernames funfred
(integer) 1
<code>では，ブルーム・フィルターに対するテストを実行してみましょう．</code>
BF.EXISTS usernames fred
(integer) 1
BF.EXISTS usernames fred_is_funny
(integer) 0
```
予想通り，fred_is_funnyは0を返しました．0というのは，このユーザ名が使われていないことを意味します．1は使用された可能性があることを意味します．複数の項目でビットが重複している可能性があるので，確実なことは言えません．</p>
</blockquote>
<p>一般に，誤検出の可能性は低いですが，ゼロではありません．ブルームフィルタが「満杯」になるにつれて，その可能性は高くなります．BF.RESERVEコマンドでエラーレートとサイズを調整することができます．</p>
<h1>カウント</h1>
<p>Redisでは様々な方法でカウントを実現することができます．最も明白なのはINCRとその仲間（INCRBY，INCRBYFLOAT，HINCRBY，HINCRBYFLOAT，ZINCRBY）で，ドキュメントを読むだけで用途と使用例が非常に明らかです．BITCOUNTとPFADDを使用する，やや説明を要する方法もあるので紹介します．</p>
<h2>ビットカウント・パターン</h2>
<p>BITCOUNTは，あるキーのビットフィールドで1にセットされたビットの数をカウントします．これは，ある期間中の一連の活動に対する洞察を提供するために活用することができます（ビットフィールド時系列でカバーされるパターンに似ていますね）．このプロセスでは，既知の時点と各ビットが表す期間を選択します．その期間中にアクションが実行されるたびに，既知のポイントからの距離を単位にSETBITを実行します．例として，ユーザーアクティビティを取り上げます．</p>
<table>
<thead>
<tr>
<th style="text-align: left;">12:00</th>
<th style="text-align: left;">12:02</th>
<th style="text-align: left;">12:03</th>
<th style="text-align: left;">12:04</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>&gt; SETBIT btct 2 1</code></td>
<td style="text-align: left;"><code>&gt; SETBIT btct 3 1</code></td>
<td style="text-align: left;"><code>&gt; SETBIT btct 4</code><br><code>1</code></td>
</tr>
<tr>
<td style="text-align: left;">known points</td>
<td style="text-align: left;">Activity</td>
<td style="text-align: left;">Activity</td>
<td style="text-align: left;">Activity</td>
</tr>
</tbody>
</table>
<p>12:00から12:30まで何分活動していたかを調べるには，コマンドを実行します．
```</p>
<blockquote>
<p>BITCOUNT btct 0 30
(integer) 3
```
一般に，このパターンは「何回」ではなく「何回」という質問に答えるものです．例えば，あるユーザーが1分間に20回「活動」しても，それは1回のカウントにしかならないからです．</p>
</blockquote>
<p>このパターンの本当の利点は，ビットがストレージの最も基本的な構成要素であることから，与えられた時間内に可能な限り小さなアカウントを提供することです．文字通り，最小の（圧縮されていない）ストレージでカウントすることができるのです．</p>
<h2>ハイパーログログ</h2>
<p>ユニークなアイテムは数えるのが難しい場合があります．通常，これはすべてのユニークなアイテムを保存し，何らかの方法でこの情報を呼び出すことを意味します．Redisでは，セットと単一のコマンドを使用してこれを達成することができますが，非常に大きなセットでは，ストレージと時間の複雑さの両方のために利用できません．そこでHyperLogLogは確率的な代替手段を提供します．</p>
<p>HyperLogLogは，非暗号化ハッシュに項目を通し，ビットフィールドの形でビットを設定するので，内部的にはブルームフィルタに似ています．ブルームフィルタとは異なり，HyperLogLogは項目のカウンタを保持しており，以前に追加されていない新しい項目が追加されると，そのカウンタがインクリメントされる．これにより，集合のユニークな項目（カーディナリティ）を推定する際に，非常に低いエラーレートを実現する．HyperLogLogはRedisに直接組み込まれています．</p>
<p>Redisには3つのHyperLogLogコマンドが入っています．PFADD，PFCOUNT，PFMERGEの3つです．例えば，ウェブクローラーを作っていて，ある1日の間にそのページがクロールしたユニークなURLの数を推定したいとしましょう．すべてのページに対して，次のようなコマンドを実行することになります．</p>
<p>```</p>
<blockquote>
<p>PFADD crawled:20171124 "http://www.google.com/"
(integer) 1
PFADD crawled:20171124 "http://www.redis.com/"
(integer) 1
PFADD crawled:20171124 "http://www.redis.io/"
(integer) 1
PFADD crawled:20171125 "http://www.redisearch.io/"
(integer) 1
PFADD crawled:20171125 "http://www.redis.io/"
(integer) 1
```
上記の各キーは，日ごとにインデックスが作成されています．2017-11-24に何ページがクロールされたかを確認するには，以下のコマンドを実行することになります．</p>
</blockquote>
<p>```</p>
<blockquote>
<p>PFCOUNT crawled:20171124
(integer) 3
```
2017-11-24と2017-11-25にクロールされたページの数を確認するには，PFMERGEを使用して，2つのカウントの和の新しいキーを生成することになります．なお，両方のキーにhttp://redis.io/ が追加されているので，2回カウントされることはありません．</p>
</blockquote>
<p>```</p>
<blockquote>
<p>PFMERGE crawled:20171124-25 crawled:20171124 crawled:20171125
OK
PFCOUNT crawled:20171124-25
(integer) 4
```
:::message
これはマルチキー操作なので，シャード環境ではキーが同じシャードに行き着くように注意してください．
:::</p>
</blockquote>
<h1>Lua Helpers</h1>
<p>Redisはredis-cliからだけでなく，Redisとあなたの選んだ言語との間でも素晴らしいことをすることができます．しかし，クライアント/サーバアーキテクチャでは効率的かつ安全に実現できない動作があり，そのロジックはデータベース層で実行される必要があります．そこで登場するのがLuaです．Luaはスクリプト言語としてRedisに組み込まれています．Luaを使えば，クライアントとの通信のオーバーヘッドなしに，Redisでアトミックにコードを実行することができます．</p>
<p>このようなタスクの例としては，ハッシュフィールドに値を追加することが挙げられます．RedisはAPPENDで文字列キーに簡単に値を追加できますが，ハッシュフィールドに値を追加するようなコマンドは存在しません．クライアントでフィールドの値を取得し，その値に新しい文字列を追加してハッシュフィールドをリセットすることで実現しようとすることはできますが，それは<strong>良くないアイディア</strong>です．これはアトミックではないので，ハッシュフィールドに値を追加している間に，他のクライアントが急襲して値を変更し，元のクライアントが新しい更新を書き換える可能性があります．</p>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">クライアント#1</th>
<th style="text-align: left;">クライアント#2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;"><code>&gt; HGET myhash myfield “hello”</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: left;">クライアントは "hello"に "world"を付加する</td>
<td style="text-align: left;"><code>&gt; HSET myhash myfield goodbye 0</code></td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: left;"><code>&gt; HSET myhash myfield “hello world”</code><br><code>0</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>&gt; HGET myhash myfield</code><br><code>"hello world"</code></td>
</tr>
</tbody>
</table>
<p>2行目でわかるように，"goodbye "への更新は失われています．Luaヘルパーを使えば，この問題を回避し，値をクライアントに移動する際の送受信のオーバーヘッドをなくすことができます．</p>
<p>任意のテキスト・エディターで，Luaスクリプトを作成する必要があります．ここでは "happend.lua" と名付けます．</p>
<p><code>lua:happend.lua
local original = redis.call('HGET',KEYS[1],ARGV[1]).
return redis.call('HSET',KEYS[1], ARGV[1], original ... ARGV[2])</code>
最初の行では，オリジナルというローカル変数を作成しています．この変数には，キー以外の最初の引数をフィールドとして，最初に渡されたキーに格納されているハッシュキーの現在値が格納されます．Luaスクリプトは，実行時にキーと非キー引数を区別していることを理解することが重要です．</p>
<p>2行目では，同じキーとフィールドに対してHSETを呼び出し，元の値と非キー引数の2つ目を連結しています．これはRedisに返されるため，HSETの元の戻り値を保持します．</p>
<p>EVALコマンドでLuaスクリプトを直接実行することもできますが，これはかなり面倒で非効率的です．Redisにはスクリプトキャッシュが内蔵されており，スクリプトを事前にロードしてから，スクリプトのSHA1ハッシュダイジェストで参照することができるのです．コマンドラインからスクリプトを読み込むには，catとredis-cliを使用します．</p>
<p><code>$ redis-cli -a yourRedisPassword SCRIPT LOAD "$(cat ./happend.lua)"
"d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099"</code>
:::message
スクリプトが1文字でも違えば，全く別のハッシュ文字列ができあがります
:::</p>
<p>さて，redis-cliではEVALSHAを使ってスクリプトを呼び出し，追記を行うことができます．
```</p>
<blockquote>
<p>HSET mynewhash greeting "hello"
(integer) 1
EVALSHA d30c7f6d0c23fcfe6d4630b11f4e3db4cb2db099 1 mynewhash greeting " world"
(integer) 0
HGET mynewhash greeting
"hello world"
```
EVALSHAコマンドを分解してみましょう．最初の引数は，SCRIPT LOADで作成したスクリプトのSHA1ダイジェストです．第2引数はキーの数です．今回は1つのキーを操作するので1です．第3引数は操作するキーです．3番目の引数は操作するフィールドで，最後に4番目の引数はフィールドに追加する値です．</p>
</blockquote>
<p>追加処理はLuaスクリプトの内部で行われるため，先ほどのシナリオは実現できません．Luaスクリプトは，完全に同期的かつアトミックに実行されます．</p>
<p>Luaは，非常に便利な問題解決ツールですが，注意深く使用する必要があります．スクリプトはサーバーをブロックし，データベースが応答しなくなる可能性があります．シャード化された状況では，スクリプトはクロスロットエラーを避けるため，すべての操作を1つのサーバーで実行しようとします．</p>